using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using VRC.Udon.Common.Interfaces;
using UnityEngine.UI;
using TMPro;
using UCS;

namespace XZDice
{
    [UdonBehaviourSyncMode(BehaviourSyncMode.Manual)]
    public class Chinchirorin : UdonSharpBehaviour
    {
        [SerializeField]
        private DieGrabSphere dieGrabSphere;
        private Die[] dice;  // Simply set to dieGrabSphere.dice in Start

        [SerializeField]
        private Collider insideBowlCollider;

        [SerializeField]
        private GameObject[] joinButtons;

        [SerializeField]
        private GameObject[] betScreens;

        [SerializeField]
        [Tooltip("Positions where the dice spawn for each player")]
        private Transform[] diceSpawns;

        [SerializeField]
        [Tooltip("Button dealer presses to start a round. One per player (because different spots).")]
        private GameObject[] startRoundButtons;

        [SerializeField]
        private GameLog gameLog;

        private UdonChips udonChips = null;

        private readonly bool DEBUG = true;

        // Max bet in part makes sure we do not go above 2^16 (even when tripled), as we serialize bets as 16 bit uint
        //   2*20000 = 60000 < 2^16 = 65536
        private readonly float MAXBET = 20000.0f;
        private readonly int MAX_PLAYERS = 4;

        // Client variables
        private int iAmPlayer = -1;
        private int oya = -1;

        // Server variables
        private bool[] playerActive; // Used only by owner
        private float[] bets; // Used only by owner
        private bool[] betDone; // Used only by owner

        private bool[] dieReadResult;
        private int[] recvResult; // Used only by owner
        int recvResult_cntr = 0; // Used only by owner
        private int rethrowCount = 0; // Used only by owner

        private int state = -1; // Used only by owner (drives the oya statemachine)

        private bool recvDieOutside = false; // Used only by owner

        // These variables are used when the oya sends messages to other players.
        // E.g. when to change udonchips balances;
        [UdonSynced] private uint arg0;
        //[UdonSynced] private uint arg1;

        private void GameLog(string message)
        {
            if (gameLog) {
                gameLog.Log(message);
            }
        }

        private void GameLogDebug(string message)
        {
            if (DEBUG)
                GameLog(message);
        }

        private void Start()
        {
            if (dieGrabSphere.dice.Length != 3)
                Debug.LogError("Must be three dice");

            // Get the dice from dieGrabSphere
            dice = new Die[dieGrabSphere.dice.Length];
            for (int i = 0; i < dieGrabSphere.dice.Length; ++i) {
                dice[i] = (Die)dieGrabSphere.dice[i].GetComponent(typeof(UdonBehaviour));
            }
            dieGrabSphere.hideOnThrow = true; // Ensure hideOnThrow is set

            if (joinButtons.Length != MAX_PLAYERS)
                Debug.LogError(string.Format("joinButtons must be {0} long", MAX_PLAYERS));

            if (betScreens.Length != MAX_PLAYERS)
                Debug.LogError(string.Format("betScreens must be {0} long", MAX_PLAYERS));

            if (diceSpawns.Length != MAX_PLAYERS)
                Debug.LogError(string.Format("diceSpawns must be {0} long", MAX_PLAYERS));


            foreach (Die die in dice) {
                die.AddListener(this);
            }

            udonChips = GameObject.Find("UdonChips").GetComponent<UdonChips>();

            ResetClientVariables();
            ResetServerVariables();
            ResetAllThings();
        }

        private void ResetClientVariables()
        {
            dieReadResult = new bool[dice.Length];
            // Below is left out on purpose
            // oya = -1;
        }

        private void ResetServerVariables()
        {
            recvResult = new int[dice.Length];
            recvResult_cntr = 0;
            playerActive = new bool[MAX_PLAYERS];
            bets = new float[MAX_PLAYERS];
            state = -1;
        }

        // Client to server communication (but sent locally if we are master)
        private void SendToOya(string fnname)
        {
            if (isOwner()) {
                SendCustomEvent(fnname);
            } else {
                SendCustomNetworkEvent(NetworkEventTarget.Owner, fnname);
            }
        }

        // Server to everybody communication. Actions are also taken on server
        private void Broadcast()
        {
            RequestSerialization();
            if (isOwner()) {
                OnDeserialization();
            }
        }

        private void SendPlayerLeaveEvent(int player)
        {
            string fnname = "EventPlayerLeave" + player.ToString();
            SendToOya(fnname);
        }

        private void RecvEventPlayerLeave(int player)
        {
            playerActive[player - 1] = false;
            BroadcastPlayerLeave(player);
        }

        private void BroadcastPlayerLeave(int player)
        {
            mkop_playerleave(player);
            Broadcast();
        }

        public void EventPlayerLeave1() { RecvEventPlayerLeave(1); }
        public void EventPlayerLeave2() { RecvEventPlayerLeave(2); }
        public void EventPlayerLeave3() { RecvEventPlayerLeave(3); }
        public void EventPlayerLeave4() { RecvEventPlayerLeave(4); }

        private void SendPlayerJoinEvent(int player)
        {
            string fnname = "EventPlayerJoin" + player.ToString();
            SendToOya(fnname);
        }

        private void RecvEventPlayerJoin(int player)
        {
            playerActive[player - 1] = true;
            BroadcastPlayerJoin(player, oya);
        }

        private void BroadcastPlayerJoin(int player, int oya)
        {
            mkop_playerjoin(player, oya);
            Broadcast();
        }

        public void EventPlayerJoin1() { RecvEventPlayerJoin(1); }
        public void EventPlayerJoin2() { RecvEventPlayerJoin(2); }
        public void EventPlayerJoin3() { RecvEventPlayerJoin(3); }
        public void EventPlayerJoin4() { RecvEventPlayerJoin(4); }

        private void LeaveGame()
        {
            if (iAmPlayer >= 0) {
                SendPlayerLeaveEvent(iAmPlayer);
            }
            // If we are currently master/oya find someone to transfer ownership to, if possible.
            // If not set up arg0 so that the game is obviously unoccupied
            if (isOwner()) {
                // We try to transfer to next player
                bool found = false;
                int idx = iAmPlayer - 1;
                for (int i = 0; i < MAX_PLAYERS; ++i) {
                    if ((idx % MAX_PLAYERS) + 1 != iAmPlayer && playerActive[idx % MAX_PLAYERS]) {
                        found = true;
                        BroadcastOyaChangeTo(iAmPlayer, (idx % MAX_PLAYERS) + 1);
                    }
                    idx++;
                }
                // If not we are obviously the last person leaving, and the game should be reset so that the first person to join becomes owner
                if (!found) {
                    BroadcastNoOya();
                }
            }

            iAmPlayer = -1;
            ResetServerVariables();
            ResetClientVariables();
        }

        private int getActivePlayerCount()
        {
            int result = 0;

            foreach (bool b in playerActive)
                if (b)
                    result++;

            return result;
        }

        private void BroadcastOyaChangeTo(int fromPlayer, int toPlayer)
        {
            mkop_oyachange(fromPlayer, toPlayer);
            Broadcast();
        }

        private void BroadcastNoOya()
        {
            mkop_nooya();
            Broadcast();
        }

        private void BtnJoinPlayer(int player)
        {
            if (iAmPlayer > 0) {
                // Already joined means we leave
                LeaveGame();
            } else {
                iAmPlayer = player;

                // First person joining when table is empty is oya
                if (op_getop() == OPCODE_NOOYA) {
                    Networking.SetOwner(Networking.LocalPlayer, gameObject);
                    BroadcastOyaChangeTo(0, iAmPlayer);
                }

                SendPlayerJoinEvent(iAmPlayer);
            }
        }

        public void BtnJoinPlayer1() { BtnJoinPlayer(1); }
        public void BtnJoinPlayer2() { BtnJoinPlayer(2); }
        public void BtnJoinPlayer3() { BtnJoinPlayer(3); }
        public void BtnJoinPlayer4() { BtnJoinPlayer(4); }

        /*
        public override bool OnOwnershipRequest(VRCPlayerApi requester, VRCPlayerApi newOwner)
        {

            if (requester.playerId == newOwner.playerId) {
                // Somebody joining attempting to grab ownership for themselves, in case there is no active owner
                if (isOya()) {
                    // Owner branch
                    if (iAmPlayer <= 0) {
                        // Owner isn't active in the game, it's fine
                        return true;
                    }
                } else {
                    //
                }
            } else {
p
            }
        }
        */

        private void SendBetEvent(int player, int bet)
        {
            string fnname = string.Format("EventPlayer{0}Bet{1}", player, bet);
            SendToOya(fnname);
        }

        private void SendBetUndoEvent(int player)
        {
            string fnname = string.Format("EventPlayer{0}BetUndo", player);
            SendToOya(fnname);
        }

        private void SendBetDoneEvent(int player)
        {
            string fnname = string.Format("EventPlayer{0}BetDone", player);
            SendToOya(fnname);
        }

        public void BtnPlayer1Bet10()   { SendBetEvent(1, 10); }
        public void BtnPlayer1Bet50()   { SendBetEvent(1, 50); }
        public void BtnPlayer1Bet100()  { SendBetEvent(1, 100); }
        public void BtnPlayer1Bet500()  { SendBetEvent(1, 500); }
        public void BtnPlayer1BetUndo() { SendBetUndoEvent(1); }
        public void BtnPlayer1BetDone() { SendBetDoneEvent(1); }

        public void BtnPlayer2Bet10()  { SendBetEvent(2, 10); }
        public void BtnPlayer2Bet50()  { SendBetEvent(2, 50); }
        public void BtnPlayer2Bet100() { SendBetEvent(2, 100); }
        public void BtnPlayer2Bet500() { SendBetEvent(2, 500); }
        public void BtnPlayer2BetUndo() { SendBetUndoEvent(2); }
        public void BtnPlayer2BetDone() { SendBetDoneEvent(2); }

        public void BtnPlayer3Bet10()  { SendBetEvent(3, 10); }
        public void BtnPlayer3Bet50()  { SendBetEvent(3, 50); }
        public void BtnPlayer3Bet100() { SendBetEvent(3, 100); }
        public void BtnPlayer3Bet500() { SendBetEvent(3, 500); }
        public void BtnPlayer3BetUndo() { SendBetUndoEvent(3); }
        public void BtnPlayer3BetDone() { SendBetDoneEvent(3); }

        public void BtnPlayer4Bet10()  { SendBetEvent(4, 10); }
        public void BtnPlayer4Bet50()  { SendBetEvent(4, 50); }
        public void BtnPlayer4Bet100() { SendBetEvent(4, 100); }
        public void BtnPlayer4Bet500() { SendBetEvent(4, 500); }
        public void BtnPlayer4BetUndo() { SendBetUndoEvent(4); }
        public void BtnPlayer4BetDone() { SendBetDoneEvent(4); }

        private void RecvBetEvent(int player, float amount)
        {
            bets[player - 1] = amount;
            BroadcastBet(player, amount);
        }

        public void RecvBetUndoEvent(int player)
        {
            bets[player - 1] = 0.0f;
            BroadcastBet(player, 0.0f);
        }

        public void RecvBetDoneEvent(int player)
        {
            betDone[player - 1] = true;
            BroadcastBetDone(player, bets[player - 1]);
        }

        // EventPlayerXBetY
        public void EventPlayer1Bet10()   { RecvBetEvent(1, 10.0f); }
        public void EventPlayer1Bet50()   { RecvBetEvent(1, 50.0f); }
        public void EventPlayer1Bet100()  { RecvBetEvent(1, 100.0f); }
        public void EventPlayer1Bet500()  { RecvBetEvent(1, 500.0f); }
        public void EventPlayer1BetUndo() { RecvBetUndoEvent(1); }
        public void EventPlayer1BetDone() { RecvBetDoneEvent(1); }

        public void EventPlayer2Bet10()   { RecvBetEvent(2, 10.0f); }
        public void EventPlayer2Bet50()   { RecvBetEvent(2, 50.0f); }
        public void EventPlayer2Bet100()  { RecvBetEvent(2, 100.0f); }
        public void EventPlayer2Bet500()  { RecvBetEvent(2, 500.0f); }
        public void EventPlayer2BetUndo() { RecvBetUndoEvent(2); }
        public void EventPlayer2BetDone() { RecvBetDoneEvent(2); }

        public void EventPlayer3Bet10()   { RecvBetEvent(3, 10.0f); }
        public void EventPlayer3Bet50()   { RecvBetEvent(3, 50.0f); }
        public void EventPlayer3Bet100()  { RecvBetEvent(3, 100.0f); }
        public void EventPlayer3Bet500()  { RecvBetEvent(3, 500.0f); }
        public void EventPlayer3BetUndo() { RecvBetUndoEvent(3); }
        public void EventPlayer3BetDone() { RecvBetDoneEvent(3); }

        public void EventPlayer4Bet10()   { RecvBetEvent(4, 10.0f); }
        public void EventPlayer4Bet50()   { RecvBetEvent(4, 50.0f); }
        public void EventPlayer4Bet100()  { RecvBetEvent(4, 100.0f); }
        public void EventPlayer4Bet500()  { RecvBetEvent(4, 500.0f); }
        public void EventPlayer4BetUndo() { RecvBetUndoEvent(4); }
        public void EventPlayer4BetDone() { RecvBetDoneEvent(4); }

        private void BroadcastBet(int player, float amount)
        {
            mkop_bet(player, amount);
            Broadcast();
        }

        private void BroadcastBetDone(int player, float total)
        {
            mkop_betdone(player, total);
            Broadcast();
        }

        private bool isOya()
        {
            return iAmPlayer == oya;
        }

        private bool isOwner()
        {
            // The oya owns the gameobject, and acts as "master" of the game
            return Networking.IsOwner(gameObject);
        }

        private void PrepareRecvThrow()
        {
            for (int i = 0; i < recvResult.Length; ++i)
                recvResult[i] = -1;
            recvResult_cntr = 0;
            recvDieOutside = false;
        }

        // DiceListener
        public void SetThrown()
        {
            for (int i = 0; i < dieReadResult.Length; ++i) {
                dieReadResult[i] = false;
            }

            if (isOwner()) {
                PrepareRecvThrow();
            } else {
                // FIXME: Actually this might not be neccessary, since the oya should know that a dice throw is about to happen
                // If we aren't the oya, we must inform the oya that we just threw, so the oya can prepare to receive the result events.
                // TODO: make sure there are no races... alternatively switch to a method where all 3 dice are sent at once (then using events won't be realistic)
                SendCustomNetworkEvent(NetworkEventTarget.Owner, nameof(SetThrown));
            }
        }

        // DiceListener
        public void SetHeld()
        {
            // Do nothing
        }

        // DiceListener
        public void DiceResult()
        {
            // Actually I think this would all probably be easier if we just handled the dice directly instead of being a listener of it...
            for (int i = 0; i < dice.Length; ++i) {
                Die die = dice[i];
                if (!dieReadResult[i] && die.GetResult() != -1) {
                    dieReadResult[i] = true;
                    SendDiceResultEvent(die.GetResult());
                    if (!insideBowlCollider.bounds.Contains(die.transform.position)) { // TODO: Or should we use the rigidbody position?
                        // If die landed outside, tell oya about this
                        SendToOya(nameof(EventDieOutside));
                    }
                }
            }
        }

        public void EventDieOutside()
        {
            recvDieOutside = true;
        }

        private void SendDiceResultEvent(int result)
        {
            switch (result) {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
                // Sends a single dice result to Oya (owner)
                string fnname = "EventDiceResult" + result.ToString();
                SendToOya(fnname);
                break;
            default:
                Debug.LogError("Invalid dice result: " + result.ToString());
                break;
            }
        }

        private void ProcessResult()
        {
            // Assert: recvResult_cntr == 3 and that recvResult contains valid numbers
            // TODO: here check the result and step the state machine
        }

        private void RecvEventDiceResult(int result)
        {
            if (result < 1 || result > 6) {
                Debug.LogError("Invalid dice result: " + result.ToString());
                return;
            }

            if (recvResult_cntr > dice.Length)
                return;

            recvResult[recvResult_cntr++] = result;

            if (recvResult_cntr == dice.Length) {
                ProcessResult();
            }
        }

        public string formatChips(float amount)
        {
            return string.Format(udonChips.format, amount);
        }

        // EventDiceResultX
        public void EventDiceResult1() { RecvEventDiceResult(1); }
        public void EventDiceResult2() { RecvEventDiceResult(2); }
        public void EventDiceResult3() { RecvEventDiceResult(3); }
        public void EventDiceResult4() { RecvEventDiceResult(4); }
        public void EventDiceResult5() { RecvEventDiceResult(5); }
        public void EventDiceResult6() { RecvEventDiceResult(6); }

        private void SetButtonText(GameObject btn, string str)
        {
            GameObject txtObj = btn.transform.GetChild(0).gameObject;
            TextMeshProUGUI text = txtObj.GetComponent<TextMeshProUGUI>();
            text.text = str;
        }

        public override void OnDeserialization()
        {
            if (op_getop() == OPCODE_ENABLE_BET) {
                if (!isOya()) {
                    GameObject bs = betScreens[iAmPlayer - 1];
                    bs.SetActive(true);
                }
            } else if (op_getop() == OPCODE_BET) {
                int player = opbet_getplayer();
                float amount = opbet_getamount();
                GameLogDebug(string.Format("P{0} increased bet by {1}", player, formatChips(amount)));
                // Here we could display chips or something coming up for each press
            } else if (op_getop() == OPCODE_BETDONE) {
                int player = opbet_getplayer();
                float total = opbet_getamount();
                betScreens[player - 1].SetActive(false);
                GameLog(string.Format("P{0} bet {1}", player, formatChips(total)));
                // TODO: update bet display label here
            } else if (op_getop() == OPCODE_PLAYERJOIN) {
                int player = opplayer_player();
                oya = opplayerjoin_oya(); // Syncs up this variable in case we don't have it
                GameLog(string.Format("P{0} entered the game", player));

                GameObject btn = joinButtons[player-1];
                if (iAmPlayer == player) {
                    // Turn the button into a leave button
                    SetButtonText(btn, "Leave");
                } else {
                    // Disable the button everywhere else
                    btn.SetActive(false);
                }
            } else if (op_getop() == OPCODE_PLAYERLEAVE) {
                int player = opplayer_player();
                GameLog(string.Format("P{0} left the game", player));

                GameObject btn = joinButtons[player-1];
                btn.SetActive(true);
                SetButtonText(btn, "Join");
            } else if (op_getop() == OPCODE_YOURTHROW) {
                int player = opthrow_player();
                int rethrow = opthrow_rethrow();

                dieGrabSphere.Show();

                if (iAmPlayer == player) {
                    dieGrabSphere.BecomeOwner();
                    dieGrabSphere.TeleportTo(diceSpawns[player - 1]);
                    dieGrabSphere.ParkDice();
                    // Make it pickupable only for the player whose turn it is
                    dieGrabSphere.SetPickupable(true);
                }

                if (rethrow > 0) {
                    GameLog(string.Format("P{0} rethrow ({1}/3)", player, rethrow + 1));
                } else {
                    GameLog(string.Format("P{0} it is your turn", player));
                }
                // TODO: perhaps a sound effect to draw the users attention? (it
                // should be fine just to do it inline here)
            } else if (op_getop() == OPCODE_THROWRESULT) {
                int player = opthrow_player();
                int[] result = opthrow_result();
                bool outside = opthrow_outside();
                if (outside)
                    GameLog(string.Format("P{0} threw outside", player));
                else
                    GameLog(string.Format("P{0} threw {1} {2} {3}", player, result[0], result[1], result[2]));
                // TODO: specific display for the result
            } else if (op_getop() == OPCODE_OYATHROWRESULT) {
                int player = opthrow_player();
                int[] result = opthrow_result();
                bool outside = opthrow_outside();
                if (outside)
                    GameLog(string.Format("P{0} (oya) threw outside", player));
                else
                    GameLog(string.Format("P{0} (oya) threw {1} {2} {3}", player, result[0], result[1], result[2]));
                // TODO: specific display for the result
            } else if (op_getop() == OPCODE_BALANCE) {
                int player = opbalance_player();
                float amount = opbalance_amount();
                if (iAmPlayer > 0 && player == iAmPlayer)
                    udonChips.money += amount;

                if (amount > 0.0f)
                    GameLog(string.Format("P{0} won {1}", player, formatChips(Mathf.Abs(amount))));
                else
                    GameLog(string.Format("P{0} lost {1}", player, formatChips(Mathf.Abs(amount))));
            } else if (op_getop() == OPCODE_OYACHANGE) {
                int toPlayer = opoyachange_toplayer();
                int fromPlayer = opoyachange_fromplayer();
                if (iAmPlayer > 0 && toPlayer == iAmPlayer) {
                    // Become owner/oya
                    if (!Networking.IsOwner(gameObject))
                        Networking.SetOwner(Networking.LocalPlayer, gameObject);
                    // Start the oya state machine here
                    state = STATE_WAITINGFORPLAYERS;
                    OyaStateMachine();
                }
                oya = toPlayer;
                // TODO: display who is oya (change playerlabel?)
                if (fromPlayer <= 0)
                    GameLog(string.Format("P{0} is oya", toPlayer));
                else
                    GameLog(string.Format("Oya P{0} -> P{1}", fromPlayer, toPlayer));
            } else if (op_getop() == OPCODE_NOOYA) {
                // TODO: reset various things like text displays, betting screens etc.
                ResetAllThings();
                ResetClientVariables();
            }
        }

        private void ResetAllThings()
        {
            foreach (GameObject btn in joinButtons) {
                btn.SetActive(true);
                SetButtonText(btn, "Join");
            }

            foreach (GameObject s in betScreens) {
                s.SetActive(false);
            }

            foreach (GameObject btn in startRoundButtons) {
                s.SetActive("false");
            }
        }

        #region states
        private readonly int STATE_WAITINGFORPLAYERS = 1;
        private readonly int STATE_WAITINGFORROUNDSTART = 2;
        private readonly int STATE_WAITINGFORBETS = 3;
        private readonly int STATE_OYATHROW = 10;
        private readonly int STATE_P1THROW = 11;
        private readonly int STATE_P2THROW = 12;
        private readonly int STATE_P3THROW = 13;
        private readonly int STATE_P4THROW = 14;
        private readonly int STATE_BALANCE = 20;

        private void OyaStateMachine()
        {
            if (!Networking.IsOwner(gameObject)) {
                Debug.LogError("OyaStateMachine called by non-owner");
                return;
            }

            if (iAmPlayer != oya) {
                Debug.LogError("OyaStateMachine called by non-oya");
                return;
            }

            // We use continue to go directly to another state and return in
            // case we need to wait on some event (reception of those events is
            // also responsible for calling the state machine again)
            while (true) {
                if (state == STATE_WAITINGFORPLAYERS) {
                    if (getActivePlayerCount() >= 2) {
                        state = STATE_WAITINGFORROUNDSTART;
                        continue;
                    }
                    return; // Wait for players to increase
                } else if (state == STATE_WAITINGFORROUNDSTART) {
                    startRoundButtons[oya - 1].SetActive(true);
                    return; // Wait for button press
                } else if (state == STATE_WAITINGFORBETS) {
                } else if (state == STATE_OYATHROW) {
                    mkop_yourthrow(oya, rethrowCount);
                    Broadcast();
                    return; // Wait on throw result
                } else if (state == STATE_P1THROW) {
                    // Skip if oya, since oya has already thrown
                    if (oya == 1) {
                        state = STATE_P2THROW;
                        continue;
                    }
                    mkop_yourthrow(1, rethrowCount);
                    Broadcast();
                    return; // Wait on throw result
                } else if (state == STATE_P2THROW) {
                    if (oya == 2) {
                        state = STATE_P3THROW;
                        continue;
                    }
                } else if (state == STATE_P3THROW) {
                    // Skip if oya, since oya has already thrown
                    if (oya == 3) {
                        state = STATE_P3THROW;
                        continue;
                    }
                } else if (state == STATE_P4THROW) {
                    // Skip if oya, since oya has already thrown
                    if (oya == 1) {
                        state = STATE_BALANCE;
                        continue;
                    }
                } else if (state == STATE_BALANCE) {
                }
            }
        }
        #endregion

        #region opcodes
        // Opcodes for all broadcasts from Oya to everyone else. sent in arg0 and (sometimes) arg1
        private readonly uint OPCODE_ENABLE_BET = 1; // Enable bet panels everywhere
        private readonly uint OPCODE_BET = 3;
        private readonly uint OPCODE_BETDONE = 4; // Display that a particular player is done betting
        private readonly uint OPCODE_PLAYERJOIN = 10; // A player has joined: Switch their join button to leave, and make it so only that player can press it
        private readonly uint OPCODE_PLAYERLEAVE = 11;
        private readonly uint OPCODE_YOURTHROW = 20; // This enables the dice for one particular player, but disables them (pickup disabled) for everyone else (if player nbr is 0 just disable)
        private readonly uint OPCODE_THROWRESULT = 21;
        private readonly uint OPCODE_OYATHROWRESULT = 22;
        private readonly uint OPCODE_BALANCE = 30;  // This applies the change to a particular players udonChips balance (Oya applies changes to own balance on their own)
        private readonly uint OPCODE_OYACHANGE = 0xFFu; // Requests that another player take over as oya
        private readonly uint OPCODE_NOOYA     = 0x00u; // Sent by the oya when it is the last person leaving, resetting the game. Also the value in arg0 on start

        uint op_getop()
        {
            return arg0 & 0xFFu;
        }

        private void mkop_enable_bet()
        {
            arg0 = OPCODE_ENABLE_BET;
        }

        private void mkop_bet(int player, float amount)
        {
            uint playerpart = (uint)player & 0b111u;   // Player numbers are three bit
            uint amountpart = (uint)amount & 0xFFFFu;  // 16 bit
            arg0 = OPCODE_BET | playerpart << 8 | amountpart << 16;
        }

        int opbet_getplayer()
        {
            return (int)((arg0 >> 8) & 0b111u);
        }

        float opbet_getamount()
        {
            return (float)((arg0 >> 16) & 0xFFFFu);
        }

        private void mkop_betdone(int player, float total)
        {
            uint playerpart = (uint)player & 0b111u;
            uint totalpart = (uint)total & 0xFFFFu;
            arg0 = OPCODE_BETDONE | playerpart << 8 | totalpart << 16;
        }

        private void mkop_playerjoin(int player, int oya)
        {
            uint playerpart = (uint)player & 0b111u;
            uint oyapart = (uint)oya & 0b111u;
            arg0 = OPCODE_PLAYERJOIN | playerpart << 8 | oyapart << 8;
        }

        private int opplayerjoin_oya()
        {
            return (int)((arg0 >> 11) & 0b111u);
        }

        private void mkop_playerleave(int player)
        {
            uint playerpart = (uint)player & 0b111u;
            arg0 = OPCODE_PLAYERLEAVE | playerpart << 8;
        }

        private int opplayer_player()
        {
            return (int)((arg0 >> 8) & 0b111u);
        }

        private void mkop_yourthrow(int player, int rethrow)
        {
            uint playerpart = (uint)player & 0b111u;
            uint rethrowpart = (uint)rethrow & 0b111u;
            arg0 = OPCODE_YOURTHROW | playerpart << 8 | rethrowpart << 19;
        }

        private uint _mkop_throw_helper(uint opcode, int player, int[] result, bool outside)
        {
            uint playerpart = (uint)player & 0b111u;
            uint resultpart =
                ((uint)result[0] & 0b111u) | ((uint)result[1] & 0b111u) << 3 | ((uint)result[2] & 0b111u) << 6;
            uint outsidepart = outside ? 1u : 0u;
            // 8 + 1 + 9 = 18 bits
            return opcode | playerpart << 8 | outsidepart << 9 | resultpart << 10;
        }

        private void mkop_throwresult(int player, int[] result, bool outside)
        {
            arg0 = _mkop_throw_helper(OPCODE_THROWRESULT, player, result, outside);
        }

        private void mkop_oyathrowresult(int player, int[] result, bool outside)
        {
            arg0 = _mkop_throw_helper(OPCODE_OYATHROWRESULT, player, result, outside);
        }

        private int opthrow_player()
        {
            return (int)((arg0 >> 8) & 0b111u);
        }

        private bool opthrow_outside()
        {
            uint outsidepart = (arg0 >> 9) & 0b1u;
            return (outsidepart == 1u) ? true : false;
        }

        private int[] opthrow_result()
        {
            int[] result = new int[3];
            uint resultpart = (arg0 >> 10);
            result[0] = (int)(resultpart & 0b111u);
            result[1] = (int)((resultpart >> 3) & 0b111u);
            result[2] = (int)((resultpart >> 6) & 0b111u);
            return result;
        }

        private int opthrow_rethrow()
        {
            return (int)((arg0 >> 19) & 0b111u);
        }

        private void mkop_balance(int player, float amount)
        {
            uint playerpart = (uint)player & 0b111u;
            uint signpart = (amount < 0.0f) ? 1u : 0u;
            uint amountpart = (uint)(amount) & 0xFFFFu;
            arg0 = OPCODE_BALANCE | playerpart << 8 | signpart << 15 | amountpart << 16;
        }

        private int opbalance_player()
        {
            return (int)((arg0 >> 8) & 0b111u);
        }

        private float opbalance_amount()
        {
            uint signpart = (arg0 >> 15) & 0b1u;
            uint amountpart = (arg0 >> 16) & 0xFFFFu;
            float sign = (signpart == 0) ? 1.0f : -1.0f;
            return sign * (float)amountpart;
        }

        private void mkop_oyachange(int fromPlayer, int toPlayer) {
            uint toPlayerPart = (uint)toPlayer & 0b111u;
            uint fromPlayerPart = (uint)fromPlayer & 0b111u;
            arg0 = OPCODE_OYACHANGE | toPlayerPart << 8 | fromPlayerPart << 11;
        }

        private int opoyachange_toplayer() {
            return (int)((arg0 >> 8) & 0b111u);
        }

        private int opoyachange_fromplayer() {
            return (int)((arg0 >> 11) & 0b111u);
        }

        private void mkop_nooya() {
            arg0 = OPCODE_NOOYA;
        }
        #endregion
    }
}
